[["index.html", "Quick R/Python Beginner Guide for Ecologists About", " Quick R/Python Beginner Guide for Ecologists Oleksii Dubovyk About This is a quick guide to the basics of programming with R and Python. Treat it is a cheatsheet. Maybe I will get enough time to extend it into a proper guide. "],["getting-started-what-is-ide.html", "Chapter 1 Getting started (what is IDE?) 1.1 Python 1.2 R", " Chapter 1 Getting started (what is IDE?) You can use any programming language in a command line (on Windows, call Win+R, write “cmd” and hit Enter, on Mac – open app called “Terminal”, on Linux – hit Ctrl+Alt+T). The command line is the most primitive way to interact with your computer through short statements: you can create or delete new directories, files, list folder contents, and much-much more. Although you theoretically can write long and complex commands, your machine will only interpret a single line at a time. So doing anything but simple tasks using a command line is not very convenient. With any programming language, you might want to have your program contained in a script. This way, instead of typing a set of commands in the command line, you can edit and save the entire script and run it as a file. The most convenient way to deal with scripts is using an IDE – integrated development environment. IDE is just another computer program that allows you to open, edit, save, and run scripts in your programming language of choice. Ideally, an IDE should work with any language (although for many of them there is also a compiling step in running a code), but surely enough some are more popular than the others. 1.1 Python 1.1.1 Installing Python To use a language, you need to install that language on your machine. You will need to do some digging to install a language, and for Python, here is a good starting point: https://www.python.org/downloads/. Ubuntu users can easily type in Terminal: sudo apt-get update sudo apt-get install python3 1.1.2 Visual Studio Code Visual Studio Code is one of the IDEs that is supposed to be used for any language. I don’t use it often though. You can download it here: https://code.visualstudio.com/download. 1.1.3 PyCharm PyCharm is pretty simple and lies somewhere between a text editor and a sophisticated IDE. It can be pretty useful to edit an existing code, but might be not enough to write a sophisticated script from scratch. You can download it here: https://www.jetbrains.com/pycharm/download/. 1.1.4 Spyder Spyder is probably one of the most complex IDEs, which will be especially intuitive for the past R/RStudio users. However, if you decide to use it, you might need to be at the level of experience where you know what pip or anaconda is, and dealing with those can be extremely annoying. Here is the download link: https://docs.spyder-ide.org/current/installation.html. 1.1.5 RStudio Yes, that’s right, RStudio for Python. The current philosophy of RStudio developers is to create a cross-platform IDE (that’s why they are renaming RStudio to Posit). We will get to RStudio later. 1.1.6 Jupiter Jupiter notebooks are pretty common nowadays because they allow you to write a whole interactive document (e.g., report, paper). This means that instead of a dry Python code, you write a real document, like a notebook, where you can embed chunks of code that will run and do something. A Jupiter notebook is something like what this guide looks like – mostly I write text, but hey, there are boxes of code that you can copy and run. A Jupiter notebook could be a good starting point for somebody who is learning Python. For example, if you don’t want to install Python locally on your computer, you can use a cloud-based Colab. The disadvantage is that all your code will be run somewhere on Google servers, so there might be a delay; besides, you need a stable Internet connection. 1.2 R 1.2.1 Installing R To install R, just follow the instructions: https://cran.r-project.org/. 1.2.2 RStudio There are other IDEs for R, but RStudio is the most prevalent one. You can download it here: https://posit.co/download/rstudio-desktop/. Note: RStudio and R are two different things. In your CV, you might want to say that you know R (the language), but don’t say that you know RStudio (the tool) – that serves as a red flag that you don’t really know what you are talking about. Saying “I have skills with RStudio” is like saying “I can use a keyboard” instead of “I am proficient in English”. "],["objects-and-data-types.html", "Chapter 2 Objects and data types 2.1 Python 2.2 R", " Chapter 2 Objects and data types Both Python and R are object-oriented high-level languages. The term “high-level” means that the programming language is written in some lower-level programming languages (e.g., C++), and thus are made to be more understandable by a human programmer (e.g., you don’t need to think about how much RAM you need to allocate to create and interact with an object – the language does it for you behind the scenes). The term “object-oriented” means that the definition of objects is central in this programming. An object is any piece of data: from a single value to entire complex datasets. In object-oriented programming, objects are often assigned to certain classes of objects. Each object from a class have certain attribute and methods that can be applied to it. For example, I have a succulent plant. I call it Steve. If it was an object in my computer, we could define the following: class: plant object: Steve attributes: age, number of leaves, biomass, etc. methods: water, plant in a larger pot, add nutrients. Python and R have slightly different approaches to operating objects, but the logic is pretty similar. But before we get there, let’s talk about the simplest types of data that can be stored in an object. 2.1 Python Boolean: the simplest logical data type, a single value out of two possible values; a flip of a coin would be a good example, and the possible values can be viewed as “heads” or “tails”, “yes” or “no”, “1” or “0”, “True” or “False”; in Python, the Boolean values are denoted as True or False; Numeric: this would be a number, and there are actually different types of a number: Integer: this is any real whole number: 1, 5000, -10000000, etc. Float: any non-integer number, e.g., 1.235, Complex number: you wouldn’t use it unless you are deep into math Sequence: any ordered sequence of values String: a sequence of characters, in Python defined with single or double quotation marks, e.g., 'Hello world' or \"Hello world\"; the length of a string can be any positive integer, from a single character to a whole paragraph of text List: an ordered list of objects of any type denoted with square brackets, e.g., [1, True, 0.25, \"apple\"]; lists can be modified after they are created; a list element can also be a list, e.g., [[1, True, 0.25, \"apple\"], \"second element here\"] Tuple: pretty much the same as a list, but cannot be modified (is immutable); a tuple is defined with parentheses, e.g., (1, True, 0.25) Dictionary: a set of key-value pairs like you would have in a dictionary, e.g., key “one”-value “uno”, defined with curly brackets as {\"key 1\": \"value 1\", \"key 2\": \"value 2\"} Set: an unordered set of unique values defined with a function set() 2.2 R Logical: same as Boolean in Python, defined as TRUE or FALSE that also can be abbreviated as T or F Numeric: any non-complex number; Character: same as string in Python, e.g., \"Hello world\" Some more complex data structures in R include vectors, data.frames, factors, which will be discussed later. "],["basic-syntax.html", "Chapter 3 Basic syntax 3.1 Python 3.2 R 3.3 Exercise", " Chapter 3 Basic syntax 3.1 Python 3.1.1 Create and play with variables Say, you want to create add two numbers. Sure, you definitely can do that: 2 + 3 ## 5 This all is not too useful though. We are not using the perks of objects, and the statement above is not much better than having a calculator. Let’s create two objects and assign integers to them. a = 2 b = 3 c = a + b print(c) ## 5 The function print() here prints out a value of an object. Without that last line, all the operation would have still happened but we would never see the result. Sowe can see that we are operating on these objects. Let’s check what class the object c belong to. The function type() allows us to look up the class of an object: type(c) ## &lt;class &#39;int&#39;&gt; There are not that many operations we can do with an integer. Let’s rewrite one of them into a float. b = 3.5 c = a + b print(c) ## 5.5 Now we can apply different functions to this object, for example, round it up, which returns an integer. round(c) ## 6 type(round(c)) ## &lt;class &#39;int&#39;&gt; You can name your objects with almost any name, except for the reserved ones (e.g., you can’t name an object True, because True is a Boolean value). Let’s see how to create objects of other classes. x1 = False Let’s check if x1 is False: x1 == False ## True So it is true that the object x1 is False. False ## False What about strings? x2 = &quot;False&quot; x2 == False ## False It is not true now, because x2 is nothing but a string of characters and not a Boolean variable. You can index a string, i.e., access a specific element (character) in a string: just like “H” is the first letter in “Hello”, “e” is the second, and so on. Be aware, however, that indexing in Python starts with zero, so that the first element has an index [0], the second – [1], the third – [2], and so on. You can also index a sequence from the end using a minus sign, so that the last character is indexed as [-1], the second to the last – [-2]. You can also specify a range of indexed values with a colon, so that [0:3] denotes characters from the first to the fourth. Indexing in Python is specified with square brackets: x2 ## &#39;False&#39; x2[0] ## &#39;F&#39; x2[1] ## &#39;a&#39; x2[2] ## &#39;l&#39; x2[-1] ## &#39;e&#39; x2[0:3] ## &#39;Fal&#39; In Python, the plus operator applied to strings concatenates them: x2[0:3] + x2[1] + x2[0] + x2[4] + x2[2] ## &#39;FalaFel&#39; Similar rules apply to lists. You can index lists, e.g., x3 = list(x2) x3 ## [&#39;F&#39;, &#39;a&#39;, &#39;l&#39;, &#39;s&#39;, &#39;e&#39;] x3[0:3] ## [&#39;F&#39;, &#39;a&#39;, &#39;l&#39;] Lists have a certain number of methods. One of the common ones is appending with another object. Notice how methods in Python are applied to objects with a period, so that you have object.method(argument). x4 = [1, 2, 3, 4] x4 ## [1, 2, 3, 4] x4.append(5) x4 ## [1, 2, 3, 4, 5] Each class of objects has a specific list of methods that can be applied to such objects. You might need to read python documentation for different classes (e.g., here). You also can save an output of a method into another object: x4.append(5) x5 = x4.count(5) x5 ## 2 3.1.2 Operators Objects in programming languages are often handled with certain operators. Here are the most common ones: Assignment: = – assign += – add and assign (x += 1 is the same as x = x + 1) Comparison: == – check if equal (output is either True or False) != – check if not equal &gt;, &gt;=, &lt;, &lt;= – check if larger than, larger or equal to, less than, less or equal to Arithmetic: +, -, *, / – add, subtract, multiply, divide ** – exponentiation % – modulo (remainder from division) // – floor division (integer of a division) Logical: and, or, not – used in Boolean expressions, e.g., to check if both expressions are satisfied (and), or either is satisfied (or) is, is not – check whether objects are identical Membership: in, not in – checks if an element is a member of some list or other sequence 3.1.3 Comments It may be useful to leave some verbal comments in your code that wouldn’t be read and executed by the computer. In Python, hash tag comments out a line of code or everything after it: a = 2 b = 3 # b = 5000 a + b # still 5, so b was never assigned as 5000. just like this text ## [1] 5 3.1.4 Loops Loops are used for iterations over a sequence, meaning that you go over each element and do something with it. for loops are more common and do something for each element, and while loops conduct iterations as long as some logical condition is satisfied. For example, for i in x4: print(i) ## 1 ## 2 ## 3 ## 4 ## 5 ## 5 does pretty much the following: for each element of x4, let’s call this element i, and then print this i. In the while loop, on the other hand number = 1 # initialize the variable # you can explicitly define the class, in which case it would be # number = int(1) while number &lt; 5: print(number) number += 1 # same as &quot;number = number + 1&quot; ## 1 ## 2 ## 3 ## 4 which the computer understands as the following: create a variable number and assign it a value of 1; then run an iteration, at each step of which print out the value of the number and increase its value by one; this process is repeated as long as the statement number &lt; 5 is True; once number becomes 5, this0 statement becomes False and the loop stops. While loops are a bit tricky because you can accidentally end up with an infinite loop. For example, while True: print(&quot;AAAAAA&quot;) If you run it, your computer will never stop yelling at you because True is always True, and the while loop execute every next iteration. 3.1.5 If/else What if you run a loop and want different outcomes under different conditions? That’s where you would use an if/else statement. For example, you for your sequence you can check if a number is odd or even: for i in x4: if i % 2 == 0: print(str(i)+&quot; is even&quot;); else: print(str(i)+&quot; is odd&quot;) ## 1 is odd ## 2 is even ## 3 is odd ## 4 is even ## 5 is odd ## 5 is odd Here, we apply a modulo operator % to our value i to check the reminder of dividing i/2 equals zero; if True, then i is even, else it is odd. There could be more complex logical operations. What is the sequence represents something that we want to classify into three levels: low (0–1), medium (2–4), or high (5 and higher): for i in x4: if i &lt;= 1: print(str(i)+&quot; is low&quot;); elif i &gt; 1 and i &lt;= 4: print(str(i)+&quot; is medium&quot;); else: print(str(i)+&quot; is high&quot;); ## 1 is low ## 2 is medium ## 3 is medium ## 4 is medium ## 5 is high ## 5 is high where elif stands for a short “else if”. 3.1.6 Functions Just like in math, a function is something that receives some input, or argument, and returns some input. For example, we want to write a function \\(f(x) = x^2\\): def f(x): return x**2 def means “define a function”, which the computer will memorize as f, it has an argument x, and the function exponentiates the argument to the power of 2. You can write an output of a function into a different variable. y = f(2) y ## 4 You can apply functions in a loop, e.g., for i in x4: print(f(i)) ## 1 ## 4 ## 9 ## 16 ## 25 ## 25 A function can have several arguments. For example, what if we want to use power different from 2? def exp(x, e = 2): return x**e In that function, we defined a default option for argument e. Now, if the function doesn’t receive the value of this argument, it will always assume that e = 2. It is a good idea to define the arguments, but otherwise Python will read them in the order they were written in the function. So that the code exp(2, 5) will generate the same output as exp(x = 2, e = 5). Note that loops and Python in general are indent-sensitive: all statements in a loop or function should be indented in a stepwise manner. For example, this code will throw out an error because there is an indent missing: def exp(x, e = 2): return x**e ## expected an indented block after function definition on line 1 (&lt;string&gt;, line 2) 3.1.7 Libraries Sometimes you want to do something, but there is no tool for it in the basic syntax and it is too hard to program on your own. Well, chances are, some programmers have already done that, packed their code into an archive somewhere online, and you can easily reuse their functions. Those archives are often called “packages”, “libraries”, or “modules”. To use a module, you need to download and build it on your machine (which usually is done with designated software), and load it into your memory before you use it. This way, you won’t need to re-type somebody else’s code in your script (because it can be thousands of lines long). For example, I want to generate a random number. Though it seems simple, there is some math involved and I don’t want to waste time tackling this problem. Well there exists a Python module for random number generation called `random``. Here is the part I don’t like too much compared to R: installing a module can be tricky, especially for a beginner. And if for some reason you need several modules that are interdependent, get ready to spend a day solving compatibility issues between them. Anyway, you might need to install pip on your computer. This little guy, a package manager, is supposed to make it easier to install modules and avoid dependency errors. After installed, you should run pip through the command line like this (erm, it actually won’t work because random is comes with Python when you install the language, but this is the syntax you could use when installing a new package): pip install random Now, at the beginning of a script, we need to tell Python the module to load. After that is done, you can call objects from the module like module.object: import random # load the module random_list = [] # initialize the list for i in range(10): # 10 iterations x = random.randint(0, 100) # create an intermediate random integer value between 0 and 11 random_list.append(x) # append the list print(random_list) ## [57, 71, 17, 50, 65, 68, 99, 60, 0, 58] You can also use aliases in module names and their parts as following: import random as rand random_list = [] for i in range(10): x = rand.randint(0, 100) random_list.append(x) print(random_list) ## [74, 44, 93, 32, 78, 59, 22, 65, 86, 31] 3.1.8 Lambda functions Lambda functions are very simple and short syntax features that are useful for tasks where you don’t really need to write a whole function. Once you run a lambda function, it is deleted from your memory. def big_function(a, b, add = True): if add: small_function = lambda a, b : a + b else: small_function = lambda a, b : a - b output = small_function(a, b) return output In this function, we first check if the argument add is True (note that if add and if add == True will produce the same result since if add = True, then the statement add == True will produce True). Depending on it, we create a small_function which adds or subtracts the arguments. Then we just apply the small_function to the big_function’s arguments a and b without a need to define clumsy small_function with def and all that stuff. 3.1.9 List comprehension List comprehension is an interesting technique that could be used to create sequences that follow a certain pattern without writing a clumsy for loop. For example, the statement doubles1 = [x*2 for x in range(0, 10)] produces the same output as doubles2 = [] for x in range(0, 10): doubles2.append(x*2); Let’s compare them: doubles1 ## [0, 2, 4, 6, 8, 10, 12, 14, 16, 18] doubles2 ## [0, 2, 4, 6, 8, 10, 12, 14, 16, 18] You can also embed if statements in comprehended lists, e.g., [x**2 for x in range(0, 10) if x&gt;3] ## [16, 25, 36, 49, 64, 81] 3.2 R 3.2.1 Create and play with variables Python style of assigning values to objects with an equal sign (e.g., x = 1) is valid in R. However, it is far more popular (and easier to read) to use an “arrow” operator &lt;-, which in RStudio can be done through a shortcut LAlt + - (left Alt and minus sign). x &lt;- 1 x ## [1] 1 Boolean values are written as TRUE/FALSE or abbreviated T/F: FALSE == F ## [1] TRUE So it is true that false is false. Characters and numeric objects are created in the same way, x1 &lt;- 1.5 x2 &lt;- &quot;x2&quot; Sequences of objects are called vectors and are created using a function c() v1 &lt;- c(1, 2, 3, 4, 5) v1 ## [1] 1 2 3 4 5 You can also create sequences of integers using colon, 1:10 ## [1] 1 2 3 4 5 6 7 8 9 10 Or sequences of values using dedicated functions seq(1, 5, 0.5) ## [1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 seq(from = 1, to = 5, length.out = 4) ## [1] 1.000000 2.333333 3.666667 5.000000 Note that indexing in R, unlike Python, begins with 1: v1[1] ## [1] 1 v1[1:3] ## [1] 1 2 3 v1[-4] ## [1] 1 2 3 5 Vectors can only contain objects of the same class. R will either throw an error or try to change all objects to one class if you try to violate this rule: c(1, 2, &quot;three&quot;) ## [1] &quot;1&quot; &quot;2&quot; &quot;three&quot; The simplest combination of vectors is a matrix. It is the same as a matrix in math and you can do linear algebra in basic R. matrix(data = 1:9, ncol = 3, nrow = 3, byrow = T) ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 ## [3,] 7 8 9 Whatever is called lists in R is different from Python. It is more similar to JSON or XML kind of objects, and perhaps closer to Python dictionaries. It can be used to store different types of data with different dimensionality. l1 &lt;- list(&quot;first element&quot; = T, &quot;second element&quot; = c(1, 2, 3, 4), &quot;third element&quot; = matrix(data = 1:9, ncol = 3, nrow = 3)) l1 ## $`first element` ## [1] TRUE ## ## $`second element` ## [1] 1 2 3 4 ## ## $`third element` ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 Note that R is not an indent-sensitive language and you can hit the next line for better readability. It all gets executed as a single line: l2 &lt;- list(&quot;first element&quot; = T, &quot;second element&quot; = c(1, 2, 3, 4), &quot;third element&quot; = matrix(data = 1:9, ncol = 3, nrow = 3)) l2 ## $`first element` ## [1] TRUE ## ## $`second element` ## [1] 1 2 3 4 ## ## $`third element` ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 You can index list elements by their index or name, e.g., (note that you have to use double brackets to index list elements) l1[[&quot;first element&quot;]] ## [1] TRUE l1[[3]] ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 l1[[2]][3] ## [1] 3 3.2.2 Operators and comments There are some differences in notation compared to the operators used in Python. Note that R operators work on vectors. In all fairness, what I said earlier about R object types wasn’t exactly correct: all single-element objects are vectors, so it’s not like “a vector is a sequence of several (say) numeric objects”, but “a single numeric value is just a numeric vector of length 1”. So look what happens when a simple arithmetic operator is applied to vectors: (-2:2) + (1:5) ## [1] -1 1 3 5 7 The operation is repeated for all elements of the vector. Assignment: = or &lt;- – assign there is also a right assignment -&gt; but I have never used it Comparison: == – check if equal (output is either True or False) != – check if not equal &gt;, &gt;=, &lt;, &lt;= – check if larger than, larger or equal to, less than, less or equal to Arithmetic: +, -, *, / – add, subtract, multiply, divide ^ or ** – exponentiation %% – modulo (remainder from division) %/% – floor division (integer of a division) %*% – matrix multiplication Logical: &amp; – vectorized AND operator &amp;&amp; – elemental AND operator, should only be used with single-element statements, | and || – vectorized and elemental OR operator, see below what the difference is Membership: %in% – checks if an element is a member of a vector; there is no “not in” operator so I often define it in my scripts: '%!in%' &lt;- function(x,y)!('%in%'(x,y)) Pipe: %&gt;% if you use tidyverse or |&gt; in latest R distributions: the idea of pipe to make a statement where you apply a result of one function to another function more readable, so instead of code that reads function4(function3(function2(function1(x)))) you could write x %&gt;% function1() %&gt;% function2() %&gt;% function3() %&gt;% function4() Regarding the difference between vectorized and elemental logical operators, vectorized ones always apply to all elements of a vector, e.g., ((-2:2) &gt;= 0) &amp; ((-2:2) &lt;= 0) ## [1] FALSE FALSE TRUE FALSE FALSE First, it evaluates the statements ((-2:2) &gt;= 0) (outputs F F T T T) and ((-2:2) &lt;= 0) (outputs T T T F F), and then applies the &amp; operator to all five pairs, yielding only one that is T and T in both vectors. Now, the statement ((-2:2) &gt;= 0) &amp;&amp; ((-2:2) &lt;= 0) will throw an error because &amp;&amp; can only be used with two single-element objects. It can be useful when you must be sure that you check single logical values and if a vector creeps in your code, then this code won’t run. As far as the comments, it’s same as in Python, everything between a # sign and the end of the line is commented out and is not executed by R. 3.2.3 Loops and if/else Syntax is fairly similar to Python, but again, indentation is not important in R. Unlike Python, you are expected to separate the statement you iterate over with parentheses, while the iterative statement is contained within curly brackets. odds &lt;- numeric() # initialize empty numeric vector evens &lt;- numeric() for (i in 1:10){ if (i %% 2 == 0){ odds &lt;- c(odds, i) # there is no append command so you have to rewrite the object at each step }else{ evens &lt;- c(evens, i) } } odds ## [1] 2 4 6 8 10 evens ## [1] 1 3 5 7 9 A neat function in R that makes if/else functions easier is ifelse (just like in Excel), which lets you fit a whole statement in one line: x &lt;- 1 ifelse(x == 1, &quot;x equals 1&quot;, &quot;x isn&#39;t equal to 1&quot;) ## [1] &quot;x equals 1&quot; 3.2.4 Functions Functions in R are defined as following: e &lt;- function(x, e = 2){ return(x^e) } So it’s very similar to Python. You don’t even need to explicitly say what to return, just a statement would suffice, although typing return is a good habit: sometimes your function can analyze a huge dataset and return nothing because you didn’t explicitly wrote it to return anything! Also, with short functions, you don’t even need to use any curly brackets, so the function above can be stripped all the way to e &lt;- function(x, e = 2) x^e 3.2.5 Apply and such apply is a family of functions that can be used to iterate a function over a multi-element object, just like list comprehension in Python (although apply can be much more complex). For example, sapply(1:5, e) ## [1] 1 4 9 16 25 We just defined the function e above so that apply knows what it is, but more often you would write temporary functions directly in there (just like lambda functions in Python): sapply(1:5, function(x){ if (x %% 2 == 0){ paste(x, &quot;is even&quot;) # btw, + doesn&#39;t concatenate strings in R like in python }else{ paste(x, &quot;is odd&quot;) } }) ## [1] &quot;1 is odd&quot; &quot;2 is even&quot; &quot;3 is odd&quot; &quot;4 is even&quot; &quot;5 is odd&quot; sapply is used for simple vectors, lapply – to iterate over a list, and apply – to two-dimensional datasets where you also have to specify a dimension (1 for row-wise operations, 2 – for column-vise), e.g., x &lt;- matrix(1:9, nrow = 3, ncol = 3) x ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 apply(x, 1, sum) ## [1] 12 15 18 apply(x, 2, sum) ## [1] 6 15 24 3.2.6 Libraries R libraries are the same as modules in Python. However, there is a central archive called CRAN for R libraries that is maintained by the same people who develop and maintain the R language. So you don’t need any external pips and such, just type directly in R language install.packages(\"YOUR-PACKAGE-NAME\") and it will get installed on your computer. At the beginning of each session, you have to call the package you want to use with a statement library(yourpackagename). Note that we use quotes for install.packages but not in library. CRAN has quite strict requirements to packages, and some packages can be found elsewhere, e.g., GitHub. For example, in my undergrad I developed some utilities for my work that really are redundant relative to big packages like vegan, that is very popular in ecology. You still can install such packages using another package, devtools: install.packages(&quot;devtools&quot;) # remember that you only call this once to install it on your computer library(devtools) # but this one you call every time you start a new R session install_github(&quot;OleksiiDubovyk/ancends&quot;) # also only call once library(ancends) # and here is my baby 3.3 Exercise 3.3.1 Exercise 1 You are going shopping for groceries, and you have a shopping list on you. Once you arrive to the store, you get a text from your partner with some more stuff to buy. Merge these two lists using different approaches: (1) in a single line of code, (2) using a for loop, and (3) using Python’s list comprehension or lambda functions, or R’s apply loops. Just to get you started, here are the lists. Define your R vector or Python list objects using appropriate syntax. your_list contains \"apples\", \"oranges\", \"bananas\", \"milk\" partner_list contains \"flour\", \"eggs\", \"potatoes\", \"cookies\", \"tea\" You want to end up with an updated your_list containing \"apples\", \"oranges\", \"bananas\", \"milk\", \"flour\", \"eggs\", \"potatoes\", \"cookies\", \"tea\". 3.3.2 Exercise 2 Learn how to deal with such sequences using the example of the updated your_list: Try indexing to return the first 3 and the last 3 elements in the list. Return only the elements that are 5 characters or longer (hint: you can get the string length using len(\"text\") in Python or str_length(\"text\") in R). 3.3.3 Exercise 3 Create a function that receives an argument of a numeric value and returns “odd” if the number is odd or “even” if the number is, well, even. Hint: you might need to use a modulo operator: odd_number %% 2 will return 0, even_number %% 2 will return 1. Once you get there, to make it even cooler, make this function return a text. E.g., if I call yourfunction(2), it should return \"2 is even\". 3.3.4 Exercise 4 Virginia state tax depends on the income. If you make between $0 and $3,000, your tax is 2%; at $3,001 – $5,000 you get taxed $60 plus 3% of any excess over $3,000; at $5,001 – $17,000 you get taxed $120 plus 5% of any excess over $5,000; and if you make more than $17,001, the state will tax you $720 plus 5.75% of any excess over $17,000. For example, if one makes $23,456, then they get taxed $720 plus \\(0.0575 \\cdot (23456 - 17000)\\), which is 5.75% of $6,456, totaling $371.22. So the total tax will be $720 + $371.22 = $1091.22 Your task is, you guessed it, to write a function that receives the annual income and returns the tax owed. 3.3.5 Exercise 5 Now, finally, ecological stuff. If you want to describe biological diversity in a community, the easiest way is to count the number of species. For example, imagine a community where you have 2 Carolina Chickadees, 5 American Goldfinches, 3 American Robins, 1 American Crow, 1 House Finch, and 1 Cooper’s Hawk. The total species richness is 6 species, but it doesn’t reflect the distribution of species abundances (e.g., we could have had 1 individual for each species, but still would end up with the species richness of 6). For that, there exist some indices of diversity, for example, Shannon index: \\[- \\sum \\limits_{i=1}^S \\frac{n_i}{N} \\cdot \\ln \\left( \\frac{n_i}{N} \\right)\\] where \\(N\\) is the total number of individuals of all species. Here, you have to calculate the ratio of each \\(i\\)th species in the community of \\(S\\) species and estimate the logarithm of those ratios. For our example, we have \\(S = 6\\), \\(N = 2 + 5 + 3 + 1 + 1 + 1= 13\\). For Carolina Chickadee, \\(n_i/N = 2/13 = 0.153\\), for American Goldfinch – \\(n_i/N = 5/13 = 0.385\\), for American Robin – \\(n_i/N = 3/13 = 0.231\\), and for everyone else \\(n_i/N = 1/13 = 0.077\\). Now we need to find logarithms of those values: \\(\\ln (1/13) = -2.57\\), \\(\\ln (2/13) = -1.87\\), \\(\\ln (3/13) = -1.47\\), and \\(\\ln (5/13) = -0.96\\). Now we just multiply \\((1/13)\\cdot\\ln(1/13) = -0.197\\), \\((2/13)\\cdot\\ln(2/13) = -0.288\\), \\((3/13)\\cdot\\ln(3/13) = -0.338\\), and \\((5/13)\\cdot\\ln(5/13) = -0.367\\). All we have left is to take a sum of all those values: \\((-0.197) + (-0.197) + (-0.197) + (-0.288) + (-0.338) + (-0.367) = -1.584\\). And our final answer is to take a negative of that, so that Shannon index for a vector of abundances \\((1,1,1,2,3,5)\\) would be \\(1.584\\). To calculate logarithms in Python, you need to call module math and use a function math.log. In R, it’s just a built-in function log. Now, write a function that takes an argument of a sequence of numbers and returns Shannon index. 3.3.6 Excercise 6 Calculate Shannon index in one line of code (hint: list comprehension in Python, sapply in R). 3.3.7 Excercise 7 Imagine that you have a list of values, say, mylist = ['apple', 'banana', 'apple', 'eggs', 'banana', 'flour', 'apple', 'sugar', 'cheese', 'tortilla', 'tomatoes', 'banana']. Write a function that would return a dictionary of all unique elements and how many times they are repeated, e.g., {'apple' : 3, 'banana' : 3, 'eggs' : 1, ...}. Write another function that returns a list of unique elements, i.e., the elements are not repeated. 3.3.8 Excercise 8 I installed a motion-activated camera on March 14, 2025, at 9 am, and took it down on March 25, 2025, at 8 am. My study protocol dictates that all setups should be exposed to potential predators for at least 10 full day (e.g., one day is 24 hours elapsed). Write a function that takes two strings representing date-time in a standardized way (e.g., \"2025-03-14 09:00:00\"), and returns True if a 10-day requirement was fulfilled. Google shall be used. 3.3.9 Excercise 9 You have a list of numeric values. For such a list, a rolling average can be calculated: it means that rather than estimating a mean for all elements in the list, you estimate a mean for some window of values. For example, with a window of 5 elements, you will estimate the mean for elements from 1 to 5, then from 2 to 6, then from 3 to 7, then from 4 to 8. That’s right, rolling average for a list is not a single value, but also a list. Write a function that takes a list of values and a window size, something like rollingavg(mylist, window = 5). 3.3.10 Excercise 10 Ticks activity is mostly dictated by local climatic conditions. For example, the eggs need to be exposed to a certain amount of warm days to hatch. Let’s see it this way: if I am an egg, I am looking at the average temperature every week. If it is less than 9°C, I don’t do anything. If it is more than 9°C, I count the difference and add it to a cumulative measure (cumulative degree-weeks). I only hatch once I reach, say, 50 CDW. Here are weekly temperatures for 52 weeks in a year: t_avg = [5.75, 6.07, 4.85, 3.77, 4.97, 4.39, 3.94, 5.63, 5.79, 7.87, 9.81, 9.92, 10.39, 12.11, 13.02, 13.58, 15.68, 16.81, 17.49, 17.98, 19.51, 22.05, 23.06, 23.88, 24.89, 25.82, 26.2, 26.41, 27.1, 27.41, 26.79, 27.01, 26.15, 25.72, 25.65, 25.18, 23.8, 22.46, 22.16, 20.42, 19.43, 17.57, 16.85, 14.4, 13.05, 12.13, 10.4, 10.14, 8.8, 8.85, 7.61, 8.27] If I am a tick, on week one it’s too cold – 5.75°C is less than 9°C, so are all the weeks until 11th. At week 11, I count 0.81°C towards my CDW, at week – 0.92°C so my CDW is now 1.73°C, at week 13 – you add 1.39°C and your CDW is now 3.12°C. And so on. Write a function that generates this rolling CDW for every week for the next 30 weeks. You can repeat the vector of average weekly temperatures, so that the week 53 would have 5.75, week 54 – 6.07, and so on. The function will take to arguments: a 52-elements-long list t_avg and the week at which we start counting cumulative degree-weeks (e.g., 1 if the eggs are laid at the first week of the year). It can be intimidating. It is difficult to wrap your head around. So it’s okay if it’s not clear nor easy. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
